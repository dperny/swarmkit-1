// Code generated by MockGen. DO NOT EDIT.
// Source: manager/allocator/network/port/port.go

// Package mock_port is a generated GoMock package.
package mock_port

import (
	api "github.com/docker/swarmkit/api"
	port "github.com/docker/swarmkit/manager/allocator/network/port"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockAllocator is a mock of Allocator interface
type MockAllocator struct {
	ctrl     *gomock.Controller
	recorder *MockAllocatorMockRecorder
}

// MockAllocatorMockRecorder is the mock recorder for MockAllocator
type MockAllocatorMockRecorder struct {
	mock *MockAllocator
}

// NewMockAllocator creates a new mock instance
func NewMockAllocator(ctrl *gomock.Controller) *MockAllocator {
	mock := &MockAllocator{ctrl: ctrl}
	mock.recorder = &MockAllocatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAllocator) EXPECT() *MockAllocatorMockRecorder {
	return m.recorder
}

// Restore mocks base method
func (m *MockAllocator) Restore(arg0 []*api.Endpoint) {
	m.ctrl.Call(m, "Restore", arg0)
}

// Restore indicates an expected call of Restore
func (mr *MockAllocatorMockRecorder) Restore(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Restore", reflect.TypeOf((*MockAllocator)(nil).Restore), arg0)
}

// Allocate mocks base method
func (m *MockAllocator) Allocate(arg0 *api.Endpoint, arg1 *api.EndpointSpec) (port.Proposal, error) {
	ret := m.ctrl.Call(m, "Allocate", arg0, arg1)
	ret0, _ := ret[0].(port.Proposal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Allocate indicates an expected call of Allocate
func (mr *MockAllocatorMockRecorder) Allocate(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Allocate", reflect.TypeOf((*MockAllocator)(nil).Allocate), arg0, arg1)
}

// Deallocate mocks base method
func (m *MockAllocator) Deallocate(arg0 *api.Endpoint) port.Proposal {
	ret := m.ctrl.Call(m, "Deallocate", arg0)
	ret0, _ := ret[0].(port.Proposal)
	return ret0
}

// Deallocate indicates an expected call of Deallocate
func (mr *MockAllocatorMockRecorder) Deallocate(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deallocate", reflect.TypeOf((*MockAllocator)(nil).Deallocate), arg0)
}

// MockProposal is a mock of Proposal interface
type MockProposal struct {
	ctrl     *gomock.Controller
	recorder *MockProposalMockRecorder
}

// MockProposalMockRecorder is the mock recorder for MockProposal
type MockProposalMockRecorder struct {
	mock *MockProposal
}

// NewMockProposal creates a new mock instance
func NewMockProposal(ctrl *gomock.Controller) *MockProposal {
	mock := &MockProposal{ctrl: ctrl}
	mock.recorder = &MockProposalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockProposal) EXPECT() *MockProposalMockRecorder {
	return m.recorder
}

// Ports mocks base method
func (m *MockProposal) Ports() []*api.PortConfig {
	ret := m.ctrl.Call(m, "Ports")
	ret0, _ := ret[0].([]*api.PortConfig)
	return ret0
}

// Ports indicates an expected call of Ports
func (mr *MockProposalMockRecorder) Ports() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ports", reflect.TypeOf((*MockProposal)(nil).Ports))
}

// Commit mocks base method
func (m *MockProposal) Commit() {
	m.ctrl.Call(m, "Commit")
}

// Commit indicates an expected call of Commit
func (mr *MockProposalMockRecorder) Commit() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockProposal)(nil).Commit))
}

// IsNoop mocks base method
func (m *MockProposal) IsNoop() bool {
	ret := m.ctrl.Call(m, "IsNoop")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsNoop indicates an expected call of IsNoop
func (mr *MockProposalMockRecorder) IsNoop() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNoop", reflect.TypeOf((*MockProposal)(nil).IsNoop))
}
